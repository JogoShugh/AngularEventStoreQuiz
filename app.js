// Generated by CoffeeScript 1.6.3
(function() {
  (function() {
    var choice, questions, quizApp, serverRoot;
    quizApp = angular.module("quizApp", ["ui.bootstrap"]);
    serverRoot = "http://localhost:2113";
    choice = function(text, correct) {
      if (correct !== true) {
        correct = false;
      }
      return {
        text: text,
        correct: correct,
        selected: false
      };
    };
    quizApp.controller('questionController', function($rootScope, $scope, questions) {
      var questionId;
      $scope.questions = questions;
      $scope.questionTextPending = {
        value: ''
      };
      $scope.selectQuestion = function(question) {
        $scope.selectedQuestion = question;
        return $scope.questionTextPending.value = question.question;
      };
      $scope.selectQuestion($scope.questions[0]);
      $scope.setChoiceCorrect = function(question, choice) {
        var otherChoice, _i, _len, _ref, _results;
        choice.correct = true;
        _ref = question.choices;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          otherChoice = _ref[_i];
          if (otherChoice !== choice) {
            _results.push(otherChoice.correct = false);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      $scope.getCorrectClass = function(correct) {
        if (correct) {
          return 'btn-primary';
        } else {
          return '';
        }
      };
      $scope.getCorrectLabel = function(correct) {
        if (correct) {
          return 'correct';
        } else {
          return 'incorrect';
        }
      };
      $scope.choiceRemove = function(question, choice) {
        if (confirm('Are you sure you want to remove this choice?')) {
          return question.choices = question.choices.filter(function(otherChoice) {
            return otherChoice !== choice;
          });
        }
      };
      $scope.choices = {
        newPending: []
      };
      $scope.choiceNewAdd = function() {
        var choiceNew;
        choiceNew = choice('');
        return $scope.choices.newPending.push(choiceNew);
      };
      $scope.choiceNewSave = function(choiceNew) {
        $scope.selectedQuestion.choices.push(choiceNew);
        return $scope.choices.newPending = $scope.choices.newPending.filter(function(otherChoice) {
          return otherChoice !== choiceNew;
        });
      };
      $scope.choiceNewDiscard = function(choiceNew) {
        if (confirm('Are you sure you want to discard this new choice?')) {
          return $scope.choices.newPending = $scope.choices.newPending.filter(function(otherChoice) {
            return otherChoice !== choiceNew;
          });
        }
      };
      $scope.questionRemove = function(question) {
        if (confirm('Are you sure you want to remove this new question?')) {
          return $scope.questions = $scope.questions.filter(function(otherQuestion) {
            return otherQuestion !== question;
          });
        }
      };
      questionId = 10;
      $scope.questionNewAdd = function() {
        var questionNew;
        questionNew = {
          id: questionId++,
          question: "Question?",
          choices: []
        };
        return $scope.questions.push(questionNew);
      };
      $scope.questionTextApply = function(question, text) {
        return question.question = text;
      };
      return $scope.questionTextRevert = function(question) {
        return $scope.questionTextPending.value = question.question;
      };
    });
    quizApp.controller("quizController", function($rootScope, $scope, $http, Poller, questions) {
      var getAnswerStreamUri, pollAnswerStream, pollCurrentAnswers, updateAnswersArray;
      $scope.questions = questions;
      getAnswerStreamUri = function(lastUri, result) {
        if ((lastUri == null) || (result == null)) {
          return serverRoot + "/streams/answers/head/backward/20?embed=content";
        } else {
          if (result.data.links[4].relation === "previous") {
            return result.data.links[4].uri + "?embed=content";
          }
        }
        return lastUri;
      };
      updateAnswersArray = function(result) {
        var _ref;
        return (_ref = $scope.answerStream).unshift.apply(_ref, result.data.entries);
      };
      $scope.userName = {
        value: "Guest" + (Math.floor(Math.random() * 100000))
      };
      pollCurrentAnswers = Poller(2000, function() {
        return serverRoot + "/projection/QuestionAnswerCoutns2/state";
      });
      $scope.currentAnswers = pollCurrentAnswers.data;
      $scope.answerStream = [];
      pollAnswerStream = Poller(2000, getAnswerStreamUri, updateAnswersArray);
      $scope.quizVisible = true;
      $scope.getCurrentAnswerCount = function(questionId, choiceText) {
        var count, ex;
        try {
          count = $scope.currentAnswers.response.questions[questionId].choices[choiceText];
          if (count == null) {
            return 0;
          }
          return count;
        } catch (_error) {
          ex = _error;
          return 0;
        }
      };
      $scope.selectAnswer = function(question, choice) {
        var currentChoice, _i, _len, _ref;
        _ref = question.choices;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          currentChoice = _ref[_i];
          if (currentChoice !== choice) {
            currentChoice.selected = false;
          }
        }
        return choice.selected = true;
      };
      return $scope.sendAnswers = function() {
        var answer, answers, question, _i, _j, _len, _len1, _ref, _ref1;
        answers = [];
        _ref = $scope.questions;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          question = _ref[_i];
          answer = {
            eventId: uuid.v4(),
            eventType: "Answer",
            data: {
              user: $scope.userName,
              answer: {
                questionId: question.id,
                text: question.text
              }
            }
          };
          _ref1 = question.choices;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            choice = _ref1[_j];
            if (choice.selected) {
              answer.data.answer.choice = choice.text;
              answer.data.answer.correct = choice.correct;
            }
          }
          answers.push(answer);
        }
        return $http.post(serverRoot + "/streams/answers", answers).success(function() {
          $scope.successMessage = "Success!";
          return $scope.quizVisible = false;
        });
      };
    });
    quizApp.factory("Poller", function($http, $timeout) {
      var createPoller;
      createPoller = function(interval, getUri, callback) {
        var data, poller, uri;
        data = {
          response: {}
        };
        uri = getUri();
        poller = function() {
          return $http.get(uri).then(function(result) {
            if (callback) {
              callback(result);
            }
            data.response = result.data;
            uri = getUri(uri, result);
            return $timeout(poller, interval);
          });
        };
        poller();
        return {
          data: data
        };
      };
      return createPoller;
    });
    questions = [
      {
        id: 1,
        question: "How should I inject a foo into a blah",
        choices: [choice("You should use constructor injection always"), choice("Consider using a functional style that passes your depdendencies via a closure", true), choice("Use a container that lets you use any kind of injection you like!")]
      }, {
        id: 2,
        question: "What style of programming do you need to use when you have lots of attributes on top of a class or method, for things like [Logged] [Transactional] [Requires(Role.Admin)]",
        choices: [choice("Aspect-oriented programming", true), choice("Magic-oriented programming"), choice("Functional programming")]
      }, {
        id: 3,
        question: "Why do you have to declare properties as virtual when you use tools that create dynamic proxies (like NHibernate)?",
        choices: [choice("Language flaw"), choice("Because a class gets created at run-time that derives from your class to stand in its place", true), choice("Because you need to create a derived class in the code-behind next")]
      }, {
        id: 4,
        question: "When you have a method that takes several parameters, what's the name of the common refactoring that lets you generalize to a single parameter?",
        choices: [choice("Pull up method"), choice("Extract interface"), choice("Refactor parameters to object", true)]
      }, {
        id: 5,
        question: "Which framework for CQRS in the .NET world went from a 'framework' to a 'reference application' (aka dead project)?",
        choices: [choice("FCQRS"), choice("C#QRS"), choice("NCQRS", true)]
      }, {
        id: 6,
        question: "When should you prefer a pull model versus a push model",
        choices: [choice("When an inventory system needs to know about recent sales"), choice("When building a large-scale searchable index", true), choice("When availability is more important than consistency")]
      }, {
        id: 7,
        question: "What is something that developers should try to do more often?",
        choices: [choice("Make systems that are able to recover from every failure"), choice("Use eventual consistency when users complain about latency"), choice("Recognize when a technical problem should be seen as a business problem that might need a business solution, not a technical solution", true)]
      }, {
        id: 8,
        question: "What phrases may help business people feel comfortable with latency between parts of your system?",
        choices: [choice("When you make a sale in the sales system, your data will be eventually consistent in the billing system"), choice("When you make a sale in the sales system, the computer may have to think a while before it shows up in billing. Call us if it takes too long.", true), choice("When you make a sale in the sales system, remember the CAP theorem: we can only guarantee any two of the following properties: Consistency, Availability, and Partition tolerence at any one time. Therefore, we cannot guarantee that sales and billing will always be in sync")]
      }, {
        id: 9,
        question: "When you do have eventual consistency between system components, what's an acceptable user experience?",
        choices: [choice("Redirect the user back to the screen to read the data they just updated immediately"), choice("Have William Shatner in Captain Kirk garb tell your user they are beaming the data into the servers. Use AJAX to poll the server for a response, and keep repeating Kirk in a loop until it's done, and then show the updated data"), choice("Lie to them. Tell them it's already done.", true)]
      }
    ];
    return quizApp.constant('questions', questions);
  })();

}).call(this);
